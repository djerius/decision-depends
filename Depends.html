<HTML>
<HEAD>
<TITLE>Depends - Track dependencies</TITLE>
<LINK REV="made" HREF="mailto:none">
</HEAD>

<BODY>

<A NAME="__index__"></A>
<!-- INDEX BEGIN -->

<UL>

	<LI><A HREF="#name">NAME</A></LI>
	<LI><A HREF="#synopsis">SYNOPSIS</A></LI>
	<LI><A HREF="#description">DESCRIPTION</A></LI>
	<UL>

		<LI><A HREF="#dependency history">Dependency history</A></LI>
		<LI><A HREF="#dry runs and changing other behavior">Dry Runs and Changing other behavior</A></LI>
		<LI><A HREF="#targets and dependencies list">Targets and Dependencies List</A></LI>
		<LI><A HREF="#targets">Targets</A></LI>
		<LI><A HREF="#dependencies">Dependencies</A></LI>
		<LI><A HREF="#action specification">Action specification</A></LI>
	</UL>

	<LI><A HREF="#subroutines">Subroutines</A></LI>
	<LI><A HREF="#export">EXPORT</A></LI>
	<LI><A HREF="#notes">NOTES</A></LI>
	<LI><A HREF="#license">LICENSE</A></LI>
	<LI><A HREF="#author">AUTHOR</A></LI>
</UL>
<!-- INDEX END -->

<HR>
<P>
<H1><A NAME="name">NAME</A></H1>
<P>Depends - Track dependencies</P>
<P>
<HR>
<H1><A NAME="synopsis">SYNOPSIS</A></H1>
<PRE>
  use Depends;</PRE>
<PRE>
  Depends::init( $depfile );
  if_dep { @targ_dep_list } sub { action };</PRE>
<P>
<HR>
<H1><A NAME="description">DESCRIPTION</A></H1>
<P><STRONG>Depends</STRONG> is a module which simplifies tracking of file dependencies
based on file time stamps and file contents.  Think of it as a
procedural version of <STRONG>make</STRONG>.</P>
<P><STRONG>Depends</STRONG> is useful when there are several steps in a process, each
of which depends upon the last.  If the process is interrupted, or if
it is to be redone with changes to parameters in later steps, and if
intermediate results can be kept, then <STRONG>Depends</STRONG> can insure that only
the minimal number of steps be redone.</P>
<P>Each step must result in a tangible product (a file).  For complicated
steps with many products the step's successful completion may be
indicated by creating an empty file whose existance indicates
completion.  This file (a <CODE>status</CODE> file in <STRONG>Depends</STRONG> terminology)
can be automatically created if requested.</P>
<P><STRONG>Depends</STRONG> determines if the product for a given step is older than
any files required to produce it.  It can also check whether the
contents of a file have changed since the product was last created.
This is useful in the case where a configuration file must be created
anew each time, but results in action only if changed since the
product was last created. Finally, it can determine if a variable's
value has changed since the product was last created.</P>
<P>
<H2><A NAME="dependency history">Dependency history</A></H2>
<P><STRONG>Depends</STRONG> must keep some dependency information between runs (for
signature and variable dependencies). It stores this in a file,
which must be named by the application.  The application indicates
the file by calling the <STRONG>Depends::init</STRONG> subroutine.</P>
<P>This file is updated after completion of successful actions and
when the program is exited.</P>
<P>
<H2><A NAME="dry runs and changing other behavior">Dry Runs and Changing other behavior</A></H2>
<P><STRONG>Depends</STRONG> can be put into a state where it checks dependencies
and pretends to update targets in order to check what actions might
need to be taken.  This is done by passing the <A HREF="#item_Pretend"><CODE>Pretend</CODE></A> attribute
to <STRONG>Depends::Init</STRONG>.  In this mode no actions are actually performed,
but are assumed to have successfully created their products.</P>
<P><STRONG>Depends</STRONG> will output to STDERR its musings if the <A HREF="#item_Verbose"><CODE>Verbose</CODE></A>
attribute is passed to <STRONG>Depends::Init</STRONG>.</P>
<P>
<H2><A NAME="targets and dependencies list">Targets and Dependencies List</A></H2>
<P>Each step must construct a single Perl list of products, also called
targets (as in <STRONG>make</STRONG>), and dependencies.  The list has a simple
syntax - it is a sequence of values, each of which may have one or
more attributes.  Attributes precede values and apply only to the next
value (unless values are grouped), and always begin with a <CODE>-</CODE>
character.  Multiple attributes may be applied to a single value.</P>
<PRE>
        -target =&gt; $file, -depend =&gt; -sig =&gt; $dep</PRE>
<P>(Note the use of the perl <CODE>=&gt;</CODE> operator to avoid quoting of
attributes.)  Values which begin with the <CODE>-</CODE> character (which may be
confused with attributes) may be passed by reference.  <STRONG>Depend</STRONG>
recognizes negative numbers, so those need not be handled specially.</P>
<PRE>
        -target =&gt; \'-strange_file', -target =&gt; -33.99e24</PRE>
<P>Values may be grouped by placing them in anonymous arrays:</P>
<PRE>
        -target =&gt; [ $file1, $file2 ]</PRE>
<P>Attributes are applied to all elements of the group; additional attributes
may modify individual group members:</P>
<PRE>
        -target =&gt; [ -sfile =&gt; $file1, $file2 ]</PRE>
<P>Groups may be nested.</P>
<P>To negate an attribute, introduce the same attribute with a prefix of
<CODE>-no_</CODE>:</P>
<PRE>
        -target =&gt; -sfile =&gt; [ $file1, -no_sfile =&gt; $file2 ]</PRE>
<P>Attributes may have values, although they are in general boolean values.
The syntax is '-attr=value'.  Note that because of the <CODE>=</CODE> character,
Perl's automatic quoting rules when using the <CODE>=&gt;</CODE> operator are
insufficient to ensure appropriate quoting.  For example</P>
<PRE>
        '-slink=foo' =&gt; $target</PRE>
<P>assigns the <CODE>-slink</CODE> attribute to <CODE>$target</CODE> and gives the attribute
the value <CODE>foo</CODE>.  If no value is specified, a default value of <CODE>1</CODE>
is assigned.  Most attributes are boolean, so no value need be assigned
them.</P>
<P>
<H2><A NAME="targets">Targets</A></H2>
<P>Targets are identified either by having the <A HREF="#item_%2Dtarget"><CODE>-target</CODE></A> attribute, or
by being the first value (or group) in the target-dependency list and
not having the <CODE>-depend</CODE> attribute.  For example, the following are
equivalent</P>
<PRE>
        ( -target =&gt; $targ1, -target =&gt; $targ2, ... )
        ( -target =&gt; [ $targ1, $targ2 ], ... )
        ( [ $targ1, $targ2 ], ... )</PRE>
<P>There must be at least one target. Target values may have the
following attributes:</P>
<DL>
<DT><STRONG><A NAME="item_%2Dtarget"><STRONG>-target</STRONG></A></STRONG><BR>
<DD>
This indicates the value is a target.
<P></P>
<DT><STRONG><A NAME="item_%2Dsfile"><STRONG>-sfile</STRONG></A></STRONG><BR>
<DD>
This indicates that the target is a status file.  It will be automatically
created upon successful completion of the step.
<P></P>
<DT><STRONG><A NAME="item_%2Dslink%3D%3Clinkfile%3E"><STRONG>-slink=&lt;linkfile</STRONG>&gt;</A></STRONG><BR>
<DD>
This indicates that the target is a status file which is linked to an
imaginary file <CODE>linkfile</CODE>.  Any step which explicitly depends upon
<CODE>linkfile</CODE> will instead depend upon the target file instead.
Multiple links to <CODE>linkfile</CODE> may be created. Links are checked in
order of appearance, and are useful only as time dependencies.  For
example, rather than depending upon the target of the previous step, a
step might depend upon the <CODE>linkfile</CODE>.  It's then possible to
introduce new intermediate steps which link their status files to
<CODE>linkfile</CODE> without having to rewrite the current step.  For example
<PRE>
        ( -target =&gt; '-slink=step1' =&gt; 'step1a', ... )
        ( -target =&gt; '-slink=step1' =&gt; 'step1b', ... )</PRE>
<PRE>
        ( -target =&gt; $result, -depend =&gt; 'step1' )</PRE>
<P>In this case, the final step will depend upon <EM>step1a</EM> and <EM>step1b</EM>.
One could later add a <EM>step1c</EM> and not have to change the dependencies
for the final step.</P>
<P>The target status file will be automatically created upon successful
completion of the step.</P>
<P></P></DL>
<P>
<H2><A NAME="dependencies">Dependencies</A></H2>
<P>Dependencies are identified either as <EM>not</EM> being the first value
(or group) in the list and not having the <A HREF="#item_%2Dtarget"><CODE>-target</CODE></A> attribute,
or by having the attribute <CODE>-depend</CODE>.  There need not be any
dependencies.</P>
<P>There are three types of dependencies: <EM>time</EM>, <EM>signature</EM>, and
<EM>variable</EM>.  The default type is <EM>time</EM>.  The defining attributes
are:</P>
<DL>
<DT><STRONG><A NAME="item_%2Dtime"><CODE>-time</CODE></A></STRONG><BR>
<DD>
Time dependencies are the default if no attribute is not specified.  A
time dependency results in a comparison of the timestamps of the
target and dependency files.  If the target is older than the
dependency file, the step must be redone.
<P></P>
<DT><STRONG><A NAME="item_%2Dsig"><CODE>-sig</CODE></A></STRONG><BR>
<DD>
Signature dependencies check the current contents of the dependency
file against the contents the last time the target was created.  If
the contents have changed, the step must be redone.  An MD5 checksum
signature is computed for signature dependency files; these are what
is stored and compared.
<P>A new signature is recorded upon successful completion of the step.</P>
<P></P>
<DT><STRONG><A NAME="item_%2Dvar"><CODE>-var</CODE></A></STRONG><BR>
<DD>
Variable dependencies check the value of a variable against its value
the last time the target was created. If the contents have changed,
the step must be redone.  The new value is recorded upon successful
completion of the step.
<P>Variable specification is a bit strange; the name of the variable
is provided as if it were another attribute:</P>
<PRE>
        -var =&gt; -var_name =&gt; $var_value</PRE>
<P>Variables cannot have the same name as any of the reserved names for
attributes.</P>
<P></P></DL>
<P>
<H2><A NAME="action specification">Action specification</A></H2>
<P><STRONG>Depends</STRONG> exports the function <STRONG>if_dep</STRONG>, which is used by the
application to specify the targets and dependencies and the action to
be taken if the dependencies have not been met.  It has the form</P>
<PRE>
  if_dep { targdep }
     action { actions };</PRE>
<P>where <EM>targdep</EM> is Perl code which results in a target and dependency
list and <EM>actions</EM> is Perl code to generate the target.
Note the final semi-colon.</P>
<P>The target dependency list code is generally very simple:</P>
<PRE>
  if_dep { -target =&gt; 'foo.out', -depend =&gt; 'foo.in' }
     action { ... }</PRE>
<P>The action routine is passed (via <CODE>@_</CODE>) a reference to a hash with
the names of targets whose dependencies were not met as the keys.  The
values are hash references, with the following keys:</P>
<DL>
<DT><STRONG><A NAME="item_time">time</A></STRONG><BR>
<DD>
A reference to an array of the dependency files which were newer than
the target.
<P></P>
<DT><STRONG><A NAME="item_var">var</A></STRONG><BR>
<DD>
A reference to an array of the variables whose values had changed.
<P></P>
<DT><STRONG><A NAME="item_sig">sig</A></STRONG><BR>
<DD>
A reference to an array of the files whose content signatures had changed.
<P></P></DL>
<P>If these lists are empty, the target file does not exist.  For example,</P>
<PRE>
  if_dep { -target =&gt; 'foo.out', -depend =&gt; 'foo.in' }
    action {
      my ( $deps ) = @_;
      ...
    };</PRE>
<P>If <EM>foo.out</EM> did not exist</P>
<PRE>
  $deps = { 'foo.out' =&gt; { time =&gt; [], 
                           var =&gt; [],
                           sig =&gt; [] } };</PRE>
<P>If <EM>foo.out</EM> did exist, but was older than <EM>foo.in</EM>,</P>
<PRE>
  %deps = { 'foo.out' =&gt; { time =&gt; [ 'foo.in' ],
                           var =&gt; [],
                           sig =&gt; [] } };</PRE>
<P>Unless the target is a status file (with attributes <A HREF="#item_%2Dsfile"><CODE>-sfile</CODE></A> or
<CODE>-slink</CODE>), the action routine <STRONG>must</STRONG> create the target file.  It <STRONG>must</STRONG>
indicate the success or failure of the action by calling <STRONG>die()</STRONG> if there
is an error:</P>
<PRE>
  if_dep { -target =&gt; 'foo.out', -depend =&gt; 'foo.in' }
    action {
      my ( $deps ) = @_;</PRE>
<PRE>
      frobnagle( 'foo.out' )
        or die( &quot;error frobnagling!\n&quot; );
    };</PRE>
<P><STRONG>if_dep</STRONG> will catch the <STRONG>die()</STRONG>. There are two manners in which
the error will be passed on by <STRONG>if_dep</STRONG>.  If <STRONG>if_dep</STRONG> is called
in a void context (i.e., its return value is being ignored), it
will <STRONG>croak()</STRONG> (See <EM>Carp</EM>).  If called in a scalar context,
it will return <CODE>true</CODE> upon success and <CODE>false</CODE> upon error.  In either
case the <CODE>$@</CODE> variable will contain the text passed to the original
<STRONG>die()</STRONG> call.</P>
<P>The following two examples have the same result:</P>
<PRE>
  eval{ if_dep { ... } action { ... } };
  die( $@ ) if $@;</PRE>
<PRE>
  if_dep { ... } action { ... } or die $@;</PRE>
<P>
<HR>
<H1><A NAME="subroutines">Subroutines</A></H1>
<DL>
<DT><STRONG><A NAME="item_Depends%3A%3Ainit">Depends::init</A></STRONG><BR>
<DD>
<PRE>
  Depends::init( $depfile, \%attr )</PRE>
<P>This routine sets the file to which <STRONG>Depends</STRONG> writes its dependency
information, as well as various attributes to control <STRONG>Depends</STRONG>
behavior.</P>
<P>A dependency file is not required if there are no signature or
variable dependencies.  In that case, if no attributes need be set,
this routine need not be called at all.  However, if attributes must
be set and no dependency file is required, pass in the undefined value
for the file name.</P>
<PRE>
  Depends::init( undef, \%attr );</PRE>
<P>The attributes are passed via a hash, with the following recognized
keys:</P>
<DL>
<DT><STRONG><A NAME="item_Pretend">Pretend</A></STRONG><BR>
<DD>
If set to a non-zero value, <STRONG>Depends</STRONG> will simulate the actions
to track what might happen.
<P></P>
<DT><STRONG><A NAME="item_Verbose">Verbose</A></STRONG><BR>
<DD>
If set to a non-zero value, <STRONG>Depends</STRONG> will be somewhat verbose.
<P></P></DL>
<P>For example,</P>
<PRE>
  Depends::init( $depfile, { Pretend =&gt; 1, Verbose =&gt; 1 } );</PRE>
</DL>
<P>
<HR>
<H1><A NAME="export">EXPORT</A></H1>
<P>The following routines are exported into the caller's namespace
<STRONG>if_dep</STRONG>, <STRONG>action</STRONG>.</P>
<P>
<HR>
<H1><A NAME="notes">NOTES</A></H1>
<P>This module was heavily influenced by the ideas in the <STRONG>cons</STRONG> software
construction tool.</P>
<P>The <CODE>{targdep}</CODE> and <CODE>{actions}</CODE> clauses to <STRONG>if_dep</STRONG> are actually
anonymous subroutines.  Any subroutine reference will do in their
stead</P>
<PRE>
  if_dep \&amp;targdep 
    action \&amp;actions;</PRE>
<P>
<HR>
<H1><A NAME="license">LICENSE</A></H1>
<P>This software is released under the GNU General Public License.  You
may find a copy at</P>
<PRE>
   <A HREF="http://www.fsf.org/copyleft/gpl.html">http://www.fsf.org/copyleft/gpl.html</A></PRE>
<P>
<HR>
<H1><A NAME="author">AUTHOR</A></H1>
<P>Diab Jerius (<A HREF="mailto:djerius@cfa.harvard.edu">djerius@cfa.harvard.edu</A>)</P>

</BODY>

</HTML>
